{{- if .Values.cleanup.enabled }}
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "chart.fullname" . }}-cleanup
  namespace: {{ .Release.Namespace }}
  annotations:
    "helm.sh/hook": pre-delete
    "helm.sh/hook-weight": "0"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
  labels:
    {{- include "chart.labels" . | nindent 4 }}
    app.kubernetes.io/component: cleanup
spec:
  template:
    metadata:
      labels:
        {{- include "chart.labels" . | nindent 8 }}
        app.kubernetes.io/component: cleanup
    spec:
      serviceAccountName: {{ include "chart.fullname" . }}-cleanup
      restartPolicy: OnFailure
      containers:
      - name: cleanup
        image: {{ .Values.cleanup.image.repository }}:{{ .Values.cleanup.image.tag | default .Chart.AppVersion }}
        imagePullPolicy: {{ .Values.cleanup.image.pullPolicy }}
        env:
        - name: UPBOT_TOKEN
          valueFrom:
            secretKeyRef:
              name: {{ .Values.upbot.apiKeyExistingSecret }}
              key: "token"
        - name: CLEANUP_TIMEOUT
          value: {{ .Values.cleanup.timeout | quote }}
        - name: CLEANUP_DRY_RUN
          value: {{ .Values.cleanup.dryRun | quote }}
        command:
        - /bin/sh
        - -c
        - |
          set -e
          echo "Starting Upbot Operator cleanup process..."
          
          # Function to log with timestamp
          log() {
            echo "$(date '+%Y-%m-%d %H:%M:%S') $1"
          }
          
          # Function to call Upbot API
          call_upbot_api() {
            local method="$1"
            local endpoint="$2"
            local data="$3"
            
            if [ -n "$data" ]; then
              curl -s -X "$method" \
                -H "Authorization: Bearer $UPBOT_TOKEN" \
                -H "Content-Type: application/json" \
                -d "$data" \
                "https://api.upbot.app/api/$endpoint"
            else
              curl -s -X "$method" \
                -H "Authorization: Bearer $UPBOT_TOKEN" \
                "https://api.upbot.app/api/$endpoint"
            fi
          }
          
          # Function to cleanup monitors from Upbot API
          cleanup_upbot_monitors() {
            log "Fetching all monitors from Upbot API..."
            
            monitors=$(call_upbot_api "GET" "monitors")
            if [ $? -ne 0 ]; then
              log "ERROR: Failed to fetch monitors from Upbot API"
              return 1
            fi
            
            # Parse monitor IDs (assuming JSON response with data array)
            monitor_ids=$(echo "$monitors" | grep -o '"id":"[^"]*"' | cut -d'"' -f4 || true)
            
            if [ -z "$monitor_ids" ]; then
              log "No monitors found in Upbot API"
              return 0
            fi
            
            monitor_count=$(echo "$monitor_ids" | wc -l)
            log "Found $monitor_count monitors to delete"
            
            if [ "$CLEANUP_DRY_RUN" = "true" ]; then
              log "DRY RUN MODE: Would delete the following monitors:"
              echo "$monitor_ids" | while read -r id; do
                log "  - Monitor ID: $id"
              done
              return 0
            fi
            
            # Delete each monitor
            failed_deletes=0
            echo "$monitor_ids" | while read -r id; do
              if [ -n "$id" ]; then
                log "Deleting monitor: $id"
                response=$(call_upbot_api "DELETE" "monitors/$id")
                if [ $? -eq 0 ]; then
                  log "Successfully deleted monitor: $id"
                else
                  log "WARNING: Failed to delete monitor: $id"
                  failed_deletes=$((failed_deletes + 1))
                fi
                sleep 1  # Rate limiting
              fi
            done
            
            if [ $failed_deletes -gt 0 ]; then
              log "WARNING: $failed_deletes monitors failed to delete"
            else
              log "All monitors deleted successfully from Upbot API"
            fi
          }
          
          # Function to cleanup Kubernetes Monitor resources
          cleanup_k8s_monitors() {
            log "Fetching Monitor resources from Kubernetes..."
            
            # Check if kubectl is available and CRD exists
            if ! command -v kubectl >/dev/null 2>&1; then
              log "ERROR: kubectl not found in container"
              return 1
            fi
            
            # Get all Monitor resources across all namespaces
            monitors=$(kubectl get monitors --all-namespaces -o json 2>/dev/null || echo '{"items":[]}')
            if [ $? -ne 0 ]; then
              log "WARNING: Failed to fetch Monitor resources (CRD might not exist)"
              return 0
            fi
            
            monitor_count=$(echo "$monitors" | grep -c '"name":' || echo "0")
            log "Found $monitor_count Monitor resources in Kubernetes"
            
            if [ "$monitor_count" = "0" ]; then
              log "No Monitor resources found in Kubernetes"
              return 0
            fi
            
            if [ "$CLEANUP_DRY_RUN" = "true" ]; then
              log "DRY RUN MODE: Would delete the following Monitor resources:"
              echo "$monitors" | grep -o '"namespace":"[^"]*","name":"[^"]*"' | while read -r monitor; do
                namespace=$(echo "$monitor" | cut -d'"' -f4)
                name=$(echo "$monitor" | cut -d'"' -f8)
                log "  - Monitor: $namespace/$name"
              done
              return 0
            fi
            
            # First, remove finalizers from all monitors to prevent hanging
            log "Removing finalizers from Monitor resources..."
            echo "$monitors" | grep -o '"namespace":"[^"]*","name":"[^"]*"' | while read -r monitor; do
              namespace=$(echo "$monitor" | cut -d'"' -f4)
              name=$(echo "$monitor" | cut -d'"' -f8)
              
              if [ -n "$namespace" ] && [ -n "$name" ]; then
                log "Removing finalizers from Monitor: $namespace/$name"
                kubectl patch monitor "$name" -n "$namespace" --type='merge' -p='{"metadata":{"finalizers":null}}' 2>/dev/null || true
              fi
            done
            
            # Wait a moment for finalizer removal to process
            sleep 2
            
            # Now delete Monitor resources (should be immediate since no finalizers)
            log "Deleting Monitor resources..."
            echo "$monitors" | grep -o '"namespace":"[^"]*","name":"[^"]*"' | while read -r monitor; do
              namespace=$(echo "$monitor" | cut -d'"' -f4)
              name=$(echo "$monitor" | cut -d'"' -f8)
              
              if [ -n "$namespace" ] && [ -n "$name" ]; then
                log "Deleting Monitor resource: $namespace/$name"
                kubectl delete monitor "$name" -n "$namespace" --ignore-not-found=true --timeout=30s
                if [ $? -eq 0 ]; then
                  log "Successfully deleted Monitor resource: $namespace/$name"
                else
                  log "WARNING: Failed to delete Monitor resource: $namespace/$name"
                fi
              fi
            done
            
            # Also try to delete the CRD if no monitors remain
            remaining=$(kubectl get monitors --all-namespaces -o json 2>/dev/null | grep -c '"name":' || echo "0")
            if [ "$remaining" = "0" ]; then
              log "All Monitor resources deleted, removing CRD..."
              kubectl delete crd monitors.monitoring.upbot.app --ignore-not-found=true --timeout=30s 2>/dev/null || true
              log "CRD cleanup completed"
            else
              log "WARNING: $remaining Monitor resources still remain, not deleting CRD"
            fi
          }
          
          # Main cleanup process
          log "=== Upbot Operator Cleanup Started ==="
          
          if [ "$CLEANUP_DRY_RUN" = "true" ]; then
            log "Running in DRY RUN mode - no actual deletions will be performed"
          fi
          
          cleanup_exit_code=0
          
          # Step 1: Cleanup Kubernetes Monitor resources first (to stop controller reconciliation)
          if [ "${CLEANUP_K8S_RESOURCES:-true}" = "true" ]; then
            log "Step 1: Cleaning up Kubernetes Monitor resources..."
            cleanup_k8s_monitors || cleanup_exit_code=1
          else
            log "Step 1: Skipping Kubernetes resource cleanup (disabled)"
          fi
          
          # Step 2: Cleanup monitors from Upbot API (external cleanup)
          if [ "${CLEANUP_UPBOT_API:-true}" = "true" ]; then
            log "Step 2: Cleaning up monitors from Upbot API..."
            cleanup_upbot_monitors || cleanup_exit_code=1
          else
            log "Step 2: Skipping Upbot API cleanup (disabled)"
          fi
          
          if [ $cleanup_exit_code -eq 0 ]; then
            log "=== Upbot Operator Cleanup Completed Successfully ==="
          else
            log "=== Upbot Operator Cleanup Completed with Warnings ==="
            log "Some cleanup operations may have failed, but this is non-fatal"
          fi
          
          # Always exit successfully to not block Helm uninstall
          exit 0
        resources:
          {{- toYaml .Values.cleanup.resources | nindent 10 }}
      {{- with .Values.cleanup.nodeSelector }}
      nodeSelector:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.cleanup.affinity }}
      affinity:
        {{- toYaml . | nindent 8 }}
      {{- end }}
      {{- with .Values.cleanup.tolerations }}
      tolerations:
        {{- toYaml . | nindent 8 }}
      {{- end }}
{{- end }}